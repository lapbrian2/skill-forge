import type { SkillSpec, GeneratedFile, Parameter } from "../types";

const typeMap: Record<string, string> = {
  string: "str", number: "float", boolean: "bool", array: "list", object: "dict",
};

function collectAllParams(spec: SkillSpec): Parameter[] {
  const allParams: Parameter[] = [];
  const seen = new Set<string>();

  for (const cap of spec.capabilities) {
    for (const p of cap.parameters || []) {
      if (!seen.has(p.name)) {
        allParams.push(p);
        seen.add(p.name);
      }
    }
  }
  for (const inp of spec.inputs || []) {
    if (!seen.has(inp.name)) {
      allParams.push({ name: inp.name, type: inp.type, description: inp.description, required: inp.required });
      seen.add(inp.name);
    }
  }
  return allParams;
}

export function generateLangchain(spec: SkillSpec): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const className = spec.name.replace(/-/g, "").replace(/\b\w/g, c => c.toUpperCase());
  const allParams = collectAllParams(spec);

  // tool.py
  const toolLines = [
    `"""${spec.name} — LangChain Tool`,
    ``,
    `${spec.description}`,
    ``,
    `Generated by Skill Forge`,
    `"""`,
    ``,
    `from typing import Optional, Type`,
    ``,
    `from langchain_core.tools import BaseTool`,
    `from pydantic import BaseModel, Field`,
    ``,
    `from schema import ${className}Input`,
    ``,
    ``,
    `class ${className}Tool(BaseTool):`,
    `    """${spec.description}"""`,
    ``,
    `    name: str = "${spec.name}"`,
    `    description: str = "${spec.description}"`,
    `    args_schema: Type[BaseModel] = ${className}Input`,
    `    return_direct: bool = False`,
    ``,
  ];

  const params = allParams.map(p => {
    const pyType = typeMap[p.type] || "str";
    return p.required ? `${p.name}: ${pyType}` : `${p.name}: ${pyType} = None`;
  }).join(", ");

  toolLines.push(`    def _run(self, ${params}) -> str:`);
  toolLines.push(`        """Execute the tool."""`);
  toolLines.push(`        # TODO: Implement tool logic`);
  toolLines.push(`        raise NotImplementedError("${spec.name} not yet implemented")`);
  toolLines.push(``);
  toolLines.push(`    async def _arun(self, **kwargs) -> str:`);
  toolLines.push(`        """Async execution — delegates to sync."""`);
  toolLines.push(`        return self._run(**kwargs)`);

  files.push({ filename: "tool.py", content: toolLines.join("\n"), framework: "langchain", type: "tool" });

  // schema.py
  const schemaLines = [
    `"""${spec.name} — Input Schema`,
    ``,
    `Pydantic model for LangChain tool input validation.`,
    ``,
    `Generated by Skill Forge`,
    `"""`,
    ``,
    `from pydantic import BaseModel, Field`,
    ``,
    ``,
    `class ${className}Input(BaseModel):`,
    `    """Input schema for ${spec.name}."""`,
    ``,
  ];

  if (allParams.length > 0) {
    for (const p of allParams) {
      const pyType = typeMap[p.type] || "str";
      if (p.required) {
        schemaLines.push(`    ${p.name}: ${pyType} = Field(description="${p.description}")`);
      } else {
        schemaLines.push(`    ${p.name}: ${pyType} = Field(default=None, description="${p.description}")`);
      }
    }
  } else {
    schemaLines.push(`    query: str = Field(description="Input query or data")`);
  }

  files.push({ filename: "schema.py", content: schemaLines.join("\n"), framework: "langchain", type: "schema" });

  return files;
}
