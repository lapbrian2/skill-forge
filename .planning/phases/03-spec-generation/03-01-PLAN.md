# Plan 03-01: Spec Rendering & Output Components

## Goal
Build rich markdown rendering for streaming specs with TOC sidebar, preview/raw toggle, copy/download, and section-level regeneration UI.

## Context
- Current `project/[id]/page.tsx` shows specs in a raw `<pre>` block — no markdown rendering
- SSE streaming is already working via `useLLMStream` hook and `llmStream()` on server
- Need to render markdown progressively as it streams in, with syntax highlighting, tables, and a live TOC
- `react-markdown` + `remark-gfm` + `rehype-highlight` is the most battle-tested combo for streaming markdown in React
- Must also support section-level regeneration (SPEC-06) — each `## N.` section can be individually re-generated

## Dependencies
- Install: `react-markdown`, `remark-gfm`, `rehype-highlight`, `highlight.js` (or use existing codemirror for highlighting)
- Existing: `useLLMStream`, `llmStream()`, `SPEC_SECTIONS`, `framer-motion`, `lucide-react`

## Wave 1: Markdown Renderer + TOC Extraction

### Task 1.1: Install dependencies
```bash
npm install react-markdown remark-gfm rehype-highlight highlight.js
```

### Task 1.2: Create `src/components/spec/markdown-renderer.tsx`
Streaming-safe markdown renderer component:
- Uses `react-markdown` with `remark-gfm` (tables, strikethrough, task lists) and `rehype-highlight` (syntax highlighting)
- Custom heading renderer that adds `id` attributes for anchor links
- Custom code block renderer with copy button
- Custom table renderer with styled borders
- Handles partial/incomplete markdown gracefully (streaming doesn't break mid-element)
- Props: `content: string`, `isStreaming: boolean`
- Memo'd to prevent unnecessary re-renders during streaming
- Include highlight.js dark theme CSS import

### Task 1.3: Create `src/components/spec/toc-sidebar.tsx`
Live table of contents sidebar that updates as spec streams:
- Extract headings from markdown content using regex: `/^(#{1,3})\s+(.+)$/gm`
- Build hierarchical TOC from h1/h2/h3 headings
- Highlight current section based on scroll position (IntersectionObserver)
- Smooth scroll-to-section on click
- Sticky positioning within the viewport
- Framer-motion enter/exit animations for new sections appearing during streaming
- Props: `content: string`, `isStreaming: boolean`, `activeSection: string`

### Task 1.4: Create `src/components/spec/spec-toolbar.tsx`
Action toolbar for the generated spec:
- Copy to clipboard button with success feedback (OUT-03)
- Download as .md file button (OUT-04)
- Toggle between rendered preview and raw markdown (OUT-02)
- Word count display
- Validation score badge (if available)
- Section count display
- Props: `content: string`, `viewMode: "preview" | "raw"`, `onViewModeChange`, `wordCount: number`, `sectionCount: number`, `validationGrade?: string`

## Wave 2: Section Regeneration + Spec Viewer

### Task 2.1: Create `src/lib/spec/section-parser.ts`
Utility for parsing spec into sections and reassembling:
- `parseSpecSections(markdown: string): SpecSection[]` — split by `## N.` headings
- `SpecSection` type: `{ number: number, title: string, content: string, level: number }`
- `replaceSection(markdown: string, sectionNumber: number, newContent: string): string` — replace one section
- `getSectionByNumber(sections: SpecSection[], number: number): SpecSection | null`
- Handle nested subsections (### 1.1, ### 1.2)

### Task 2.2: Create `src/components/spec/section-actions.tsx`
Per-section action overlay:
- Appears on hover over section headings
- "Regenerate this section" button with loading state
- "Copy section" button
- Uses section-parser to identify section boundaries
- Props: `sectionNumber: number`, `isRegenerating: boolean`, `onRegenerate`, `onCopy`

### Task 2.3: Create `src/components/spec/spec-viewer.tsx`
Main spec viewer component composing all sub-components:
- Layout: TOC sidebar (left, 200px) + content area (right, flex)
- Toolbar at top of content area
- MarkdownRenderer for preview mode, CodeMirror for raw mode
- Section hover actions overlaid on rendered markdown
- Scroll sync between TOC and content
- Streaming state: show progress indicator, dim sections not yet complete
- Props: `content: string`, `isStreaming: boolean`, `project: Project`, `onRegenerate: (sectionNumber: number) => void`

## Wave 3: API Route for Section Regeneration + Page Integration

### Task 3.1: Create `src/app/api/generate-section/route.ts`
New API route for single-section regeneration:
- POST body: `{ section_number, section_title, project_data, current_spec, complexity }`
- Uses `llmStream()` with a focused prompt that only generates one section
- Returns SSE stream of the regenerated section content
- System prompt instructs: maintain consistency with rest of spec, use same entity names

### Task 3.2: Add `promptRegenerateSection()` to prompts.ts
New prompt template:
- Takes: section_number, section_title, project_data (brief + features + architecture), existing spec context
- Instructs AI to regenerate ONLY the specified section
- Must maintain consistency with rest of spec (entity names, field types, patterns)
- Include the surrounding section context for coherence

### Task 3.3: Rewrite spec-related sections of `project/[id]/page.tsx`
Replace the current `<pre>` spec display with the new `SpecViewer`:
- Import and use SpecViewer component
- Wire up section regeneration: when user clicks "regenerate" on a section, call generate-section API, stream the result, then splice it into the full spec using section-parser
- Update saved spec in localStorage after regeneration
- Handle streaming state transitions properly

## Verification
- [ ] Streaming spec renders with proper markdown formatting (headings, code blocks, tables)
- [ ] TOC sidebar updates in real-time as sections stream in
- [ ] Toggle between preview and raw markdown works
- [ ] Copy to clipboard copies the full raw markdown
- [ ] Download produces a valid .md file
- [ ] Individual section can be regenerated without losing other sections
- [ ] Regenerated section maintains entity/field consistency with rest of spec
- [ ] Code blocks have syntax highlighting
- [ ] Build passes with no TypeScript errors
